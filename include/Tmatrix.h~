/* Tmatrix class - Encapsulates the Eigen matrix container
*/

#ifndef TMATRIX_H
#define TMATRIX_H

#include <iostream>
#include <Eigen/Dense>

#include "Tvector.h"

namespace TNoddy
{
    // Forward declare the Tsparse_matrix class that will be friends with Tmatrix
    template <typename T>
    class Tsparse_matrix;

    // Forward declare the Teigensystem class that will be friends with Tmatrix
    template <typename T>
    class Teigensystem;

	// Templated matrix class
	template <typename T>

	
	class Tmatrix 
	{
		
		private:
				std::size_t ROWS;					// Number of rows 
				std::size_t COLS;					// Number of columns
				Eigen::Matrix<T, -1, -1> MATRIX;	// Dynamic matrix object
                friend class Tsparse_matrix<T>;     // Friend class that may access MATRIX directly
                friend class Teigensystem<T>;       // Friend class that may access MATRIX directly

		public:
				// Constructor for an empty matrix of unspecified size
				Tmatrix();

				// Constructor for a matrix with specfied initial elements
				Tmatrix( const std::size_t& rows, const std::size_t& cols, const T& elem );

				// Copy constructor
    		    Tmatrix( const Tmatrix<T>& source );

				// Destructor
	   		    ~Tmatrix();

				/* ----- Operator overloading ----- */

				// Assignment
    			Tmatrix& operator=( const Tmatrix& original );

				// Indexing operator (read only)
				const T& operator() ( const std::size_t& i, const std::size_t& j ) const;
                
                // Indexing operator (read/write)
				T& operator() ( const std::size_t& i, const std::size_t& j );

				// Output operator <<
				template <class Type>
				friend std::ostream& operator<<( std::ostream& os, const Tmatrix<Type>& mat );

				// Unary +
				Tmatrix<T> operator+() const;

				// Unary -
				Tmatrix<T> operator-() const;

				// Binary + 
				Tmatrix<T> operator+( const Tmatrix<T>& m_plus ) const;

				// Binary -
				Tmatrix<T> operator-( const Tmatrix<T>& m_minus ) const;

				// Scalar multiplication
				Tmatrix<T> operator*( const T& m ) const;

				// Scalar division
				Tmatrix<T> operator/( const T& m ) const;

				// Matrix multiplication
				Tmatrix<T> operator*( const Tmatrix<T>& m_times );

				// Addition assigment +=
				Tmatrix<T>& operator+=( const Tmatrix<T>& m_plus );
		
				// Subtraction assignment -=
				Tmatrix<T>& operator-=( const Tmatrix<T>& m_minus );
				
				/* ----- Methods ----- */
				
				// Return the number of rows in the matrix
				std::size_t rows() const;

				// Return the number of columns in the matrix
				std::size_t cols() const;

				// Return the number of elements in the matrix
				std::size_t numel() const;

				// Fill the matrix with specified elements
				void fill( const T& elem );

				// Fill the leading diagonal with specified elements
				void fill_diag( const T& elem );

                // Fill a diagonal band of the matrix
                void fill_band( const std::size_t& offset, const T& value );

				// Return the transpose of the matrix
				Tmatrix<T> transpose() const;

				// Return the conjugate of the matrix
				Tmatrix<T> conjugate() const;

				// Return the adjoint of the matrix
				Tmatrix<T> adjoint() const;

				// Return the trace of the matrix
				T trace() const;

				// Return the sum of all the elements in the matrix
				T sum() const;

				// Return the product of all the elements in the matrix
				T prod() const;

				// Return the mean of all the elements in the matrix
				T mean() const;

                // Set a column of the matrix
                void set_col( const std::size_t& col, const Tvector<T>& x );

                // Resize the matrix ( sets all elements equal to zero )
                void resize( const std::size_t& rows, const std::size_t& cols );

                /* ----- Norms ----- */

                // Return the maximum absolute column sum of the matrix
                double norm_1() const;

                // Return the maximum absolute row sum of the matrix
                double norm_inf() const;

                // Return the Frobenius norm of the matrix
                double norm_frob() const;

                // Return the entrywise max-norm of the matrix
                double norm_max() const;

                // Return the entrywise p-norm of the matrix (p=2 is Frobenius, p=inf is max norm)
                double norm_p( const double& p ) const;

                /* ----- Solve linear system of equations ----- */

                // Solve system of equations Ax=b where x and b are vectors  
                Tvector<T> solve( const Tvector<T>& b, const std::string method = "LU"  ) const;                 

                // Solve system of equations AX=B where X and B are matrices
                Tmatrix<T> solve( const Tmatrix<T>& B, const std::string method = "LU" ) const;    

	}; // End of class Tmatrix

	/* ----- Inline definitions for some methods for speed improvement ----- */

	/* ----- Operator overloading ----- */

	// Assignment
	template <typename T>
    inline Tmatrix<T>& Tmatrix<T>::operator=( const Tmatrix<T>& original )
	{		
		MATRIX = original.MATRIX;
		ROWS = original.ROWS;
		COLS = original.COLS;
		return *this;
	}

	// Indexing operator (read only)
	template <typename T>
	inline const T& Tmatrix<T>::operator() ( const std::size_t& i, const std::size_t& j ) const
	{
		assert( i >= 0 && i < ROWS );
		assert( j >= 0 && j < COLS );
		return MATRIX(i,j);
	}

	// Indexing operator (read/write)
	template <typename T>
	inline T& Tmatrix<T>::operator() ( const std::size_t& i, const std::size_t& j )
	{
		assert( i >= 0 && i < ROWS );
		assert( j >= 0 && j < COLS );
		return MATRIX(i,j);
	}

	// Output operator <<
	template <class T>
	inline std::ostream& operator<<( std::ostream& os, const Tmatrix<T>& mat )
	{	
		os << std::endl;
		for (std::size_t i=0; i<mat.ROWS; ++i)
		{
			for (std::size_t j=0; j<mat.COLS-1; ++j)
			{
				os << mat.MATRIX(i,j) << ", ";
			}
			os << mat.MATRIX(i,mat.COLS-1) << std::endl;		
		}
		return os;
	}

	// Unary +
	template <typename T>
  	inline Tmatrix<T> Tmatrix<T>::operator+() const
  	{
    		return *this;
  	}

	// Unary -
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator-() const
	{
		Tmatrix<T> temp( *this );
		temp.MATRIX = -temp.MATRIX;
		return temp;
	}
	
	// Binary + 
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator+( const Tmatrix<T>& m_plus ) const
	{
		assert( m_plus.ROWS == ROWS && m_plus.COLS == COLS );
		Tmatrix<T> temp( *this );
		temp.MATRIX += m_plus.MATRIX;
		return temp;
	}

	// Binary -
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator-( const Tmatrix<T>& m_minus ) const
	{
		assert( m_minus.ROWS == ROWS && m_minus.COLS == COLS );
		Tmatrix<T> temp( *this );
		temp.MATRIX -= m_minus.MATRIX;
		return temp;
	} 

	// Scalar multiplication
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator*( const T& m ) const
	{
		Tmatrix<T> temp( *this );
		for (size_t j = 0; j < temp.COLS; ++j)
		{
			for (size_t i = 0; i < temp.ROWS; ++i)
			{
				temp( i, j ) *= m;
			}
		}
		return temp;
	}
	
	// Scalar division
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator/( const T& m ) const
	{
		Tmatrix<T> temp( *this );
		for (size_t j = 0; j < temp.COLS; ++j)
		{
			for (size_t i = 0; i < temp.ROWS; ++i)
			{
				temp( i, j ) /= m;
			}
		}
		return temp;
	} 

	// Matrix multiplication
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::operator*( const Tmatrix<T>& m_times )
	{
		assert( COLS == m_times.ROWS );
		Tmatrix<T> temp(ROWS, m_times.COLS, 0.0);
		temp.MATRIX = MATRIX * m_times.MATRIX;
		return temp;
	}

	// Addition assigment +=
	template <typename T>
	inline Tmatrix<T>& Tmatrix<T>::operator+=( const Tmatrix<T>& m_plus )
	{
		assert( m_plus.ROWS == ROWS && m_plus.COLS == COLS );
		MATRIX = MATRIX + m_plus.MATRIX;
		return *this;
	}
		
	// Subtraction assignment -=
	template <typename T>
	inline Tmatrix<T>& Tmatrix<T>::operator-=( const Tmatrix<T>& m_minus )
	{
		assert( m_minus.ROWS == ROWS && m_minus.COLS == COLS );
		MATRIX = MATRIX - m_minus.MATRIX;
		return *this;
	}

	/* ----- Methods ----- */
	
	// Return the number of rows in the matrix	
	template <typename T>
  	inline std::size_t Tmatrix<T>::rows() const
  	{
    	return ROWS;
  	}

	// Return the number of columns in the matrix
	template <typename T>
	inline std::size_t Tmatrix<T>::cols() const
	{
		return COLS;
	}

	// Return the transpose of the matrix
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::transpose() const
	{
		Tmatrix<T> temp( *this );
		Tmatrix<T> trans(COLS,ROWS,0.0);
		trans.MATRIX = temp.MATRIX.transpose();
		return trans;
	}

	// Return the conjugate of the matrix
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::conjugate() const
	{
		Tmatrix<T> temp( *this );	
		Tmatrix<T> conj(ROWS,COLS,0.0);
		conj.MATRIX = temp.MATRIX.conjugate();
		return conj;
	}

	// Return the adjoint of the matrix
	template <typename T>
	inline Tmatrix<T> Tmatrix<T>::adjoint() const
	{
		Tmatrix<T> temp( *this );	
		Tmatrix<T> adj(COLS,ROWS,0.0);
		adj.MATRIX = temp.MATRIX.adjoint();
		return adj;
	}

} // End of namespace TNoddy

#endif
