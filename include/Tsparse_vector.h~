/* Tsparse_vector class
*/
 
#ifndef TSPARSE_VECTOR_H
#define TSPARSE_VECTOR_H

#include <map>
#include <cassert>

namespace TNoddy
{
    // Forward declare the Tsparse_matrix class that will be friends with Tsparse_vector
	template <typename T>
  	class Tsparse_matrix;

	// Templated sparse vector class.
	template <typename T>

	class Tsparse_vector
	{

    typedef typename std::map< std::size_t, T >::const_iterator citer;
    typedef typename std::map< std::size_t, T >::iterator iter;

    private:
        std::map< std::size_t, T > CONTAINER;       // Container for storing the elements in 
        std::size_t MAX_SIZE;                       // Maximum size of the container
        T ZERO;                                     // Zero element of type T  
        friend class Tsparse_matrix<T>;			    // Friend class that may access CONTAINER directly     
	
	public:

        /* ----- Constructors and destructors ----- */
        
        // Constructor for an empty sparse vector of unspecified maximum size
        Tsparse_vector();

        // Constructor for a sparse vector of specified maximum size
        Tsparse_vector( const std::size_t& max_size ); 

        // Copy constructor
        Tsparse_vector( const Tsparse_vector& source );

        // Destructor
        ~Tsparse_vector();

        /* ----- Operator overloading ----- */
        
        // Assignment
    	Tsparse_vector& operator=( const Tsparse_vector<T>& original );
		
		// Indexing (read/write)
		T& operator[] ( const std::size_t& i );	

		// Indexing (read only)
		const T& operator[] (const std::size_t& i) const;

        // Unary +
        Tsparse_vector<T> operator+() const;

        // Unary -
        Tsparse_vector<T> operator-() const;

        // Binary +
        Tsparse_vector<T> operator+( const Tsparse_vector<T>& sv_plus );

        // Binary -
        Tsparse_vector<T> operator-( const Tsparse_vector<T>& sv_minus );

        // Scalar multiplication *
        Tsparse_vector<T> operator*( const T& m );

        // Addition assignement +=
        Tsparse_vector<T> operator+=( const Tsparse_vector<T>& sv_plus );

        // Subtraction assignment -= 
        Tsparse_vector<T> operator-=( const Tsparse_vector<T>& sv_minus ); 

        // Scalar multiplication assignment *=
        Tsparse_vector<T> operator*=( const T& m );
			
		// Output operator <<
		template <class Type>
		friend std::ostream& operator<<( std::ostream& os, const Tsparse_vector<Type>& vec );

        /* ----- Methods ----- */

        // Maximum size of the sparse vector
		std::size_t max_size() const;

        // Resize the sparse vector
        void resize( const std::size_t& n );

        // Remove all the elements from the sparse vector
        void clear();

        // Erase an element from the sparse vector
        void erase( const std::size_t& index );

        // Swap elements i and j
        void swap( const std::size_t& i, const std::size_t& j );

        // Number of non-zero elements in the sparse vector
        std::size_t numel() const;

        // Set an element of the vector
        T& set( const std::size_t& i );

        // Get an element of the vector
        const T& get( const std::size_t& i ) const;

        // Check if the vector is empty
        bool isempty() const;

        // Return an std::vector of indices for elements in the vector
        std::vector<std::size_t> index_list() const;

        // Return an std::vector of the elements in the vector (same order as index_list)
        std::vector<T> element_list() const;

        // Look for an element index
        citer find( std::size_t i ) const
        {
          citer pos;
          pos = CONTAINER.find( i );
          return pos;
        }

        /* ----- Norms ----- */

        // L1 norm: sum of absolute values 
		double norm_1() const;

		// L2 norm: square root of the sum of the squares 
		double norm_2() const;

		// Lp norm: p-th root of the sum of the absolute values raised to the power p
		double norm_p( const double& p ) const;

		// Inf norm: largest absolute value element (p -> infinity)
		double norm_inf() const;

        /* ----- Iterators ----- */

        // Iterator pointing to the first element
		iter begin() 
		{
			return CONTAINER.begin();
		}

		// Iterator pointing to the last element
		iter end()
		{
			return CONTAINER.end();
		}
		
	   	
	}; // End of Tsparse_vector class

	/* ----- Inline definitions for some methods for speed improvement ----- */
	
    // Assignment
    template <typename T>
    inline Tsparse_vector<T>& Tsparse_vector<T>::operator=( const Tsparse_vector<T>& original )
    {
        CONTAINER = original.CONTAINER;
        ZERO = original.ZERO;
        MAX_SIZE = original.MAX_SIZE;
        return *this;
    }
		
	// Indexing (read/write)
    template <typename T>
	inline T& Tsparse_vector<T>::operator[] ( const std::size_t& i )
    {
        assert( i >= 0 && i < CONTAINER.max_size() );
    	return CONTAINER[ i ];
    }

	// Indexing (read only)
    template <typename T>
	inline const T& Tsparse_vector<T>::operator[] (const std::size_t& i) const
    {
        assert( i >= 0 && i < CONTAINER.max_size() );
    	citer pos;
        pos = CONTAINER.find( i );
        if ( pos != CONTAINER.end() )
        {
            return pos -> second;
        }
        else
        {
            return ZERO;
        }
    }

    // Output operator <<
	template <class T>
	inline std::ostream& operator<<( std::ostream& os, const Tsparse_vector<T>& vec )
	{	
        typedef typename std::map< std::size_t, T >::const_iterator citer;
        if ( vec.CONTAINER.begin() == vec.CONTAINER.end() )
        {
            os << "[ Empty vector ]" << std::endl;
        }
        else
        {
            for ( citer pos = vec.CONTAINER.begin(); pos != vec.CONTAINER.end(); ++pos )
            {
                os << "([" << pos -> first << "], " << pos -> second << ") ";
            }
            os << std::endl;
        }
	}

    // Erase an element from the sparse vector
    template <typename T>
    inline void Tsparse_vector<T>::erase( const std::size_t& index )
    {
        CONTAINER.erase( index );
    }	

    // Number of non-zero elements in the sparse vector
    template <typename T>
    inline std::size_t Tsparse_vector<T>::numel() const
    {
        return CONTAINER.size();
    }

    // Get an element of the vector
    template <typename T>
    inline const T& Tsparse_vector<T>::get( const std::size_t& i ) const
    {
        assert( i <= max_size() && i >=0 );
        citer pos;
        pos = CONTAINER.find( i );
        if ( pos != CONTAINER.end() )
        {
            return pos -> second;
        }
        else
        {
            return ZERO;
        }
    }

    // Check if the vector is empty
    template <typename T>
    inline bool Tsparse_vector<T>::isempty() const
    {
        if ( CONTAINER.begin() == CONTAINER.end() )
        {
            return true;
        }
        else
        {
            return false;
        }
    }

} // End of namespace TNoddy

#endif
