/* Tvector class - Encapsulates the std::vector container
   adding operator overloading and a few useful functions.
*/
 
#ifndef TVECTOR_H
#define TVECTOR_H

#include <vector>
#include <complex>
#include <algorithm>
#include <functional>
#include <cassert>
#include <iostream>
#include <initializer_list>



namespace TNoddy
{
	// Forward declare the Tmatrix class that will be friends with Tvector
	template <typename T>
  	class Tmatrix;

    // Forward declare the Tsparse_matrix class that will be friends with Tvector
    template <typename T>
    class Tsparse_matrix;

	// Templated vector class.
	template <typename T>

	class Tvector
	{

	private:
        std::vector<T> CONTAINER;			// Private member vector container
		friend class Tmatrix<T>;			// Friend class that may access CONTAINER directly
        friend class Tsparse_matrix<T>;     // Friend class that may access CONTAINER directly
	
	public:

		typedef typename std::vector<T>::iterator iter;
        typedef typename std::vector<T>::const_iterator citer;

		/* ----- Constructors and Destructor ----- */
	
		// Constructor for an empty vector of unspecfied size
	    Tvector();

		// Constructor for list initialised vector ( ONLY AVAILABLE IN C++11 )
		//Tvector( std::initializer_list<T> list ) : CONTAINER( list ) { }

		// Constructor for a vector of specified size and non-zero elements
    	Tvector( const std::size_t& size, const T& elem );

		// Copy constructor
		template <typename _sourceType>
		Tvector( const Tvector<_sourceType>& source )
		{
		   	CONTAINER.resize( source.size() );	// Resize the CONTAINER
		   	iter ptr_cont( CONTAINER.begin() );	// Iterator for the start of CONTAINER

			// Iterator pointing to the start of the source Tvector
			typename Tvector<_sourceType>::citer ptr_source = source.begin();
			for ( std::size_t i = 0; i < source.size(); ++i)
			{
				*ptr_cont = *ptr_source;	    // Point to the same memory address
				++ptr_source;			        // Increment pointers
				++ptr_cont;	
			}
	    	}	

		// Destructor
	   	~Tvector();	

		/* ----- Operator overloading ----- */

		// Assignment
    	Tvector& operator=( const Tvector<T>& original );
		
		// Indexing (read/write)
		T& operator[] ( const std::size_t& i );	

		// Indexing (read only)
		const T& operator[] (const std::size_t& i) const;

		// Unary +
		Tvector<T> operator+() const;

		// Unary -
		Tvector<T> operator-() const;

		// Binary + 
		Tvector<T> operator+( const Tvector<T>& v_plus ) const;

		// Binary -
		Tvector<T> operator-( const Tvector<T>& v_minus ) const;

		// Scalar multiplication
		Tvector<T> operator*( const T& m ) const;

		// Scalar division
		Tvector<T> operator/( const T& m ) const;

		// Addition assigment +=
		Tvector<T>& operator+=( const Tvector<T>& v_plus );
		
		// Subtraction assignment -=
		Tvector<T>& operator-=( const Tvector<T>& v_minus );

		// Multiplication assignment *=
		Tvector<T>& operator*=( const Tvector<T>& v_times );

		// Division assignment /=
		Tvector<T>& operator/=( const Tvector<T>& v_divide );

		// Output operator <<
		template <class Type>
		friend std::ostream& operator<<( std::ostream& os, const Tvector<Type>& vec );
		
		/* ----- Methods ----- */

		// Size of the vector
		std::size_t size() const;

		// Push_back a new element into the end of the vector
		void push_back( const T& new_elem );

		// Resize the vector so that it contains n elements
		void resize( const std::size_t& n );

		// Request that the vector has at least enough to contain n elements
		void reserve( const std::size_t& n );

		// Return the size of the storage space currently allocated for the vector
		std::size_t capacity() const;

		// Clear all the elements from the vector
		void clear();

		// Return a vector of absolute values of the elements
		Tvector<double> abs() const;

		// Swap elements i and j
		void swap( const std::size_t& i, const std::size_t& j );

		// Assign new contents to the vector
		void assign( const std::size_t& n, const T& elem );

		// Create a linearly spaced vector (of doubles) with n elements
		void linspace( const double& a, const double& b, const std::size_t& n );

		// Product of the elements in the vector (from index start to end)
		T product( const std::size_t& start, const std::size_t& end );

		// Sum of the elements in the vector (from index start to end)
		T sum( const std::size_t& start, const std::size_t& end );

        // Scale each element of the vector, equivalent to *=
        void scale( const T& scale );

		/* ----- Norms ----- */

		// L1 norm: sum of absolute values 
		double norm_1() const;

		// L2 norm: square root of the sum of the squares 
		double norm_2() const;

		// Lp norm: p-th root of the sum of the absolute values raised to the power p
		double norm_p( const double& p ) const;

		// Inf norm: largest absolute value element (p -> infinity)
		double norm_inf() const;

		/* ----- Iterators ----- */

		// Iterator pointing to the first element
		iter begin() 
		{
			return CONTAINER.begin();
		}

		// Iterator pointing to the last element
		iter end()
		{
			return CONTAINER.end();
		}	
		
		
	   	
	}; // End of Tvector class

	/* ----- Inline definitions for some methods for speed improvement ----- */
	
	// Destructor
	template <typename T>
  	inline Tvector<T>::~Tvector()
  	{}

	// Assignment
	template <typename T>
	inline Tvector<T>& Tvector<T>::operator=( const Tvector<T>& original)
	{
		CONTAINER = original.CONTAINER;
		return *this;
	}

	// Indexing (read/write)
	template <typename T>
  	inline T& Tvector<T>::operator[] ( const std::size_t& i )
  	{
		assert( i >= 0 && i < CONTAINER.size() );
    	return CONTAINER[ i ];
  	}

	// Indexing (read only)
	template <typename T>
	inline const T& Tvector<T>::operator[] (const std::size_t& i) const
	{
		assert( i >= 0 && i < CONTAINER.size() );
    	return CONTAINER[ i ];
  	}

	// Unary +
	template <typename T>
  	inline Tvector<T> Tvector<T>::operator+() const
  	{
    	return *this;
  	}

	// Unary -
	template <typename T>
	inline Tvector<T> Tvector<T>::operator-() const
	{
		Tvector<T> temp( *this );
		iter start = temp.CONTAINER.begin();
		iter end   = temp.CONTAINER.end();
		std::transform( start, end, start, std::negate<T>() );
		return temp;
	}

	// Binary + 
	template <typename T>
	inline Tvector<T> Tvector<T>::operator+( const Tvector<T>& v_plus ) const
	{
		assert( v_plus.size() == size() );
		Tvector<T> temp( *this );
		temp += v_plus;
		return temp;
	}

	// Binary -
	template <typename T>
	inline Tvector<T> Tvector<T>::operator-( const Tvector<T>& v_minus ) const
	{
		assert( v_minus.size() == size() );
		Tvector<T> temp( *this );
		temp -= v_minus;
		return temp;
	}

	// Scalar multiplication
	template <typename T>
	inline Tvector<T> Tvector<T>::operator*( const T& m ) const
	{
		Tvector<T> temp( *this );
		for (size_t i = 0; i < temp.size(); ++i)
		{
			temp[ i ] *= m;
		}
		return temp;
	}

	// Scalar division
	template <typename T>
	inline Tvector<T> Tvector<T>::operator/( const T& m ) const
	{
		Tvector<T> temp( *this );
		for (size_t i = 0; i < temp.size(); ++i)
		{
			temp[ i ] /= m;
		}
		return temp;
	}

	// Addition assigment +=
	template <typename T>
  	inline Tvector<T>& Tvector<T>::operator+=( const Tvector<T>& v_plus )
  	{
		assert( v_plus.size() == size() );
		iter start = CONTAINER.begin();
		iter end   = CONTAINER.end();
    	std::transform( start, end, v_plus.CONTAINER.begin(), start, std::plus<T>() );
    	return *this;
  	}

	// Subtraction assignment -=
	template <typename T>
	inline Tvector<T>& Tvector<T>::operator-=( const Tvector<T>& v_minus )
	{
		assert( v_minus.size() == size() );
		iter start = CONTAINER.begin();
		iter end   = CONTAINER.end();
    	std::transform( start, end, v_minus.CONTAINER.begin(), start, std::minus<T>() );
    	return *this;
	}

	// Multiplication assignment *=
	template <typename T>
	inline Tvector<T>& Tvector<T>::operator*=( const Tvector<T>& v_times )
	{
		assert( v_times.size() == size() );
		iter start = CONTAINER.begin();
		iter end   = CONTAINER.end();
    	std::transform( start, end, v_times.CONTAINER.begin(), start, std::multiplies<T>() );
    	return *this;
	}

	// Division assignment /=
	template <typename T>
	inline Tvector<T>& Tvector<T>::operator/=( const Tvector<T>& v_divide )
	{
		assert( v_divide.size() == size() );
		iter start = CONTAINER.begin();
		iter end   = CONTAINER.end();
    	std::transform( start, end, v_divide.CONTAINER.begin(), start, std::divides<T>() );
    	return *this;
	}

	// Output operator <<
	template <class T>
	inline std::ostream& operator<<( std::ostream& os, const Tvector<T>& vec )
	{	
		os << "[";
		for (std::size_t i=0; i<vec.size()-1; i++)
		{
			os << vec.CONTAINER[ i ] << ", ";
		}
		
		os << vec.CONTAINER[ vec.size() - 1 ]<<"]";
		return os;
	}

	// Size of the vector
	template <typename T>
  	inline std::size_t Tvector<T>::size() const
  	{
    	return CONTAINER.size();
  	}

	// Push_back a new element into the end of the vector
	template <typename T>
	inline void Tvector<T>::push_back( const T& new_elem )
	{
	    CONTAINER.push_back( new_elem );
	}

	// Resize the vector so that it contains n elements
	template <typename T>
	inline void Tvector<T>::resize( const std::size_t& n )
	{
		CONTAINER.resize( n );
	}

	// Request that the vector has at least enough to contain n elements
	template <typename T>
	inline void Tvector<T>::reserve( const std::size_t& n )
	{
		CONTAINER.reserve( n );
	}

	// Return the size of the storage space currently allocated for the vector
	template <typename T>
	inline std::size_t Tvector<T>::capacity() const
	{
		return CONTAINER.capacity();
	}

	// Clear all the elements from the vector
	template <typename T>
	inline void Tvector<T>::clear()
	{
		CONTAINER.clear();
	}

	// Assign new contents to the vector
	template <typename T>
	inline void Tvector<T>::assign( const std::size_t& n, const T& elem )
	{
		CONTAINER.assign( n, elem );
	}

	// Create a linearly spaced vector (of doubles) with n elements (specialised function)
	template <>
	inline void Tvector<double>::linspace( const double& a, const double& b, const std::size_t& n )
	{
		CONTAINER.resize( n );
		const double h = ( b - a ) / (n - 1)  ;
		for ( std::size_t i=0; i < n; ++i ) 
		{		
			CONTAINER[ i ] = a + h * i;
		}
	}

	// Product of the elements in the vector (from index start to end)
	template <typename T>
	inline T Tvector<T>::product( const std::size_t& start, const std::size_t& end )
	{
		assert( start < end && start >=0 && start < CONTAINER.size() && end > 0 && end < CONTAINER.size() );
		Tvector<T> temp( *this );
		T prod( temp.CONTAINER[start] ); // First value
		for ( std::size_t i=start+1; i<=end; ++i )
		{
			prod *= temp.CONTAINER[ i ];
		}
		return prod;
	}

	// Sum of the elements in the vector (from index start to end)
	template <typename T>
	inline T Tvector<T>::sum( const std::size_t& start, const std::size_t& end )
	{
		assert( start < end && start >=0 && start < CONTAINER.size() && end > 0 && end < CONTAINER.size() );
		Tvector<T> temp( *this );
		T S( temp.CONTAINER[start] ); // First value
		for ( std::size_t i=start+1; i<=end; ++i )
		{
			S += temp.CONTAINER[ i ];
		}
		return S;
	}	

} // End of namespace TNoddy

#endif
