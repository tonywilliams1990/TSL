/* Tode_bvp - Here we define the Tode_bvp class used for solving ODE
			  boundary value problems. 
*/

#ifndef TODE_BVP_H
#define TODE_BVP_H

#include <iostream>
#include <vector>

#include "Tvector.h"
#include "Tmatrix.h"
#include "Tsparse_vector.h"
#include "Tsparse_matrix.h"
#include "Tequation.h"
#include "ToneD_node_mesh.h"

namespace TNoddy
{

	// Templated ODE boundary value problem class
	template < typename T, typename X = double >

	class Tode_bvp 
	{
        private:	
			Tequation<T, X> *ptr_EQUATION; 	            // Pointer to ODE equation
            Tresidual<T> *ptr_LEFT_RESIDUAL;            // Pointer to the left residual
            Tresidual<T> *ptr_RIGHT_RESIDUAL;           // Pointer to the right residual
            ToneD_node_mesh<T, X> SOLUTION;             // Solution mesh
            std::size_t MAX_ITER;			            // Maximum number of iterations
            double TOL;						            // Tolerance for convergence
            Tvector<T> NODES;                           // Vector of nodes ( defines the domain ) 
            double DELTA;                               // Perturbation step for computation of the Jacobian
    
		public:	
			
            /* ----- Constructors and destructors ----- */

			// Constructor
            Tode_bvp( Tequation<T, X>* ptr_equation, const Tvector<T>& nodes, Tresidual<T>* ptr_left_residual, 
                      Tresidual<T>* ptr_right_residual );

            // Copy constructor
			Tode_bvp(  const Tode_bvp& source );

			// Destructor
        	virtual ~Tode_bvp();
			
            /* ----- Methods ----- */

            // Return a pointer to DELTA
            double& delta();

            // Return a pointer to MAX_ITER
            std::size_t& max_iter();

            // Return the current solution mesh
			ToneD_node_mesh<T, X>& solution();
            
            // Solve the BVP - do iterate while residual > tol and iter < max_iter
			void solve();

	}; // End of class Tode_bvp	

} // End of namespace TNoddy

#endif
